import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, "..");
const v10Dir = path.join(repoRoot, "v10");
const outputPath = path.join(v10Dir, "AI_READ_ME_MAP.md");

const args = process.argv.slice(2);
const isCheck = args.includes("--check");

const IGNORED_DIRS = new Set([
  ".git",
  ".github",
  "node_modules",
  ".next",
  "dist",
  "build",
  "out",
  "coverage",
  ".turbo",
  ".vercel",
  ".cache",
]);
const IGNORED_FILES = new Set([".DS_Store", "AI_READ_ME_MAP.md"]);

function isIgnored(entry) {
  if (entry.name.startsWith(".")) {
    return true;
  }
  if (entry.isDirectory()) {
    return IGNORED_DIRS.has(entry.name);
  }
  return IGNORED_FILES.has(entry.name);
}

function sortEntries(entries) {
  return entries.sort((a, b) => {
    if (a.isDirectory() !== b.isDirectory()) {
      return a.isDirectory() ? -1 : 1;
    }
    return a.name.localeCompare(b.name);
  });
}

function readDirEntries(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  return sortEntries(entries.filter((entry) => !isIgnored(entry)));
}

function walkTree(dir, prefix, depth, maxDepth, lines) {
  const entries = readDirEntries(dir);
  entries.forEach((entry, index) => {
    const isLast = index === entries.length - 1;
    const connector = isLast ? "\\-- " : "|-- ";
    const suffix = entry.isDirectory() ? "/" : "";
    lines.push(`${prefix}${connector}${entry.name}${suffix}`);

    if (entry.isDirectory() && depth < maxDepth) {
      const nextPrefix = prefix + (isLast ? "    " : "|   ");
      walkTree(path.join(dir, entry.name), nextPrefix, depth + 1, maxDepth, lines);
    }
  });
}

function buildTree(dir, maxDepth) {
  const rel = path.relative(repoRoot, dir).replace(/\\/g, "/");
  const rootLabel = rel.length ? `${rel}/` : "./";
  const lines = [rootLabel];
  walkTree(dir, "", 1, maxDepth, lines);
  return lines;
}

function ensureDirExists(dir, optional) {
  if (fs.existsSync(dir)) {
    return true;
  }
  if (optional) {
    return false;
  }
  throw new Error(`Missing required directory: ${dir}`);
}

function buildOutput() {
  if (!fs.existsSync(v10Dir)) {
    throw new Error("Missing v10/ directory at repo root.");
  }

  const sections = [
    { title: "v10/ (top-level)", dir: v10Dir, maxDepth: 1, optional: false },
    { title: "v10/src/", dir: path.join(v10Dir, "src"), maxDepth: 4, optional: false },
    { title: "v10/public/", dir: path.join(v10Dir, "public"), maxDepth: 2, optional: true },
    { title: "v10/prisma/", dir: path.join(v10Dir, "prisma"), maxDepth: 2, optional: true },
  ];

  const lines = [
    "# AI_READ_ME_MAP (auto-generated)",
    "",
    "This file is generated by `node scripts/gen_ai_read_me_map.mjs`.",
    "Do not edit by hand. Use `--check` in CI.",
    "",
    "Map scope: v10 structure only. See `v10/AI_READ_ME.md` for semantic rules.",
    "",
  ];

  sections.forEach((section) => {
    if (!ensureDirExists(section.dir, section.optional)) {
      return;
    }
    lines.push(`## ${section.title}`);
    lines.push("```text");
    lines.push(...buildTree(section.dir, section.maxDepth));
    lines.push("```");
    lines.push("");
  });

  return lines.join("\n");
}

function main() {
  const output = buildOutput();

  if (isCheck) {
    let existing = "";
    try {
      existing = fs.readFileSync(outputPath, "utf8");
    } catch {
      console.error(
        "AI_READ_ME_MAP.md is missing. Run: node scripts/gen_ai_read_me_map.mjs"
      );
      process.exit(1);
    }

    if (existing !== output) {
      console.error(
        "AI_READ_ME_MAP.md is out of date. Run: node scripts/gen_ai_read_me_map.mjs"
      );
      process.exit(1);
    }
    process.exit(0);
  }

  fs.writeFileSync(outputPath, output, "utf8");
  console.log(`Wrote ${path.relative(repoRoot, outputPath)}`);
}

main();
