# AI_READ_ME (v10 Deep Map)

This file is the v10 implementation/architecture reference map.

## Governance Note
- Workflow authority order is defined by `AGENTS.md`.
- This document must not redefine SSOT priority; it only maps v10 architecture and invariants.

## Suggested Read Flow (v10 implementation context)
1) `PROJECT_BLUEPRINT.md` + `PROJECT_CONTEXT.md`  
2) `AGENTS.md` (authority + execution rules)  
3) Task spec in `codex_tasks/`  
4) `GEMINI_CODEX_PROTOCOL.md` (only when layout/SVG coordination is relevant)

---

## AI_READ_ME_MAP (Auto-generated)
- `v10/AI_READ_ME_MAP.md` is generated by `node scripts/gen_ai_read_me_map.mjs`.
- CI checks freshness via `node scripts/gen_ai_read_me_map.mjs --check`.

---

## Layer Rules (Hard Boundaries)
**Allowed imports**
- `core` imports: **only** other `core` modules
- `features` imports: `core` + `ui` only
- `ui` imports: **only** `ui` + `core` (no `features`)
- `app` can import `features` and `ui`

**Forbidden patterns**
- No `window` globals.
- No `eval` / `new Function`.
- No `src/lib` (deprecated).
- No Prisma client or generated code inside `src/`.
- HTML must be sanitized when using `innerHTML`.

**Aliases**
- `@core/*` → `v10/src/core/*`
- `@features/*` → `v10/src/features/*`
- `@ui/*` → `v10/src/ui/*`
- `@/*` → `v10/src/*`

---

## Directory Map (v10/src)
```
app/
  globals.css
  layout.tsx
  page.tsx
core/
  engine/        (headless command bus: command registry, preflight, idempotency)
  contracts/     (NormalizedContent/RenderPlan/TTSScript/ToolResult/ToolRegistry contract types, guards, mappers)
  config/        (boardSpec, capabilities, typography defaults, rolePolicy + guards)
  export/        (export pipeline scaffold)
  extensions/    (manifest, registry, connectors, pluginLoader, mcpGateway, runtime scaffold)
  math/          (MathJax loader/render)
  migrations/    (migrateToV2)
  persistence/   (buildPersistedDoc and doc-only shaping helpers)
  sanitize/      (richTextSanitizer)
  themes/        (chalk theme)
  types/         (canvas data types)
  utils.ts       (shared utility helpers)
features/
  animation/     (animation model, plan/measure/runtime, modding contract)
  canvas/        (rendering layers, actors, objects, viewport)
  extensions/    (tool adapter interfaces/registry/mock adapter, command policy + command registrations)
  hooks/         (useSequence, usePersistence, useFileIO, useAudioPlayer, ...)
  layout/        (AppLayout, autoLayout, overview)
  policy/        (policy shadow comparison telemetry helpers)
  store/         (zustand state)
  toolbar/       (toolbar + panels)
ui/
  components/    (pure UI building blocks)
```

---

## Canvas Layering (Notes)
- `features/canvas/PageViewport.tsx` exposes an `overlay` slot for screen-space layers (rendered outside the zoom/pan transform).
- `features/canvas/PageGuides.tsx` uses screen-space coordinates and expands its SVG viewport to avoid clipping while panning/zooming.
- `features/canvas/CanvasGuides.tsx` remains inside the transformed board space (alignment guides).

---

## Data Model (Core Concepts)
**Global steps**
- Step indices are **global**, not per-page.
- `currentStep` always references the global step index.
- `stepBlocks` is **1:1** with global steps (block index == step index).

**StepBlocks**
- Ordered blocks used to build layout.
- `kind` can be `content`, `line-break`, `column-break`, `page-break`.
- Every block (including breaks) increments the step index.

**AnchorMap**
- `AnchorMap: Record<pageId, Record<stepIndex, AnchorPosition[]>>`
- Used by playback cursor (anchor indicator); includes anchors for break blocks.

**audioByStep**
- Optional audio mapped by **global step index**.

**PersistedSlateDoc**
- Document-only payload for storage/export (no session fields).
- Includes optional `animationModInput` (format-agnostic external profile payload).

---

## Store Schemas (Zustand)

### 3-tier stores (authority layer)
- `useDocStore`: persisted document authority (`pages`, `pageOrder`, `pageColumnCounts`, `stepBlocks`, `anchorMap`, `audioByStep`, `animationModInput`)
- `useSyncStore`: shared/session-sync authority (`globalStep`, `laserPosition`, `sharedViewport`, `pendingAIQueue`)
- `useLocalStore`: local device/role authority (`role`, `isPanelOpen`, `localViewport`)

### Legacy interaction stores (still active)
- `useCanvasStore`: canvas mutation + layout/session actions (draw, page/step/block mutation facade)

### UI domain split stores (task_127 scaffold)
- `useToolStore`: tool/pen/laser state
- `useViewportStore`: overview/viewport/view-mode/guides state
- `usePlaybackStore`: autoplay/playback/sound state
- `useChromeStore`: panel/paste-helper/data-input/fullscreen/chrome toggles
- `useCapabilityStore`: capability profile and capability checks
- `useUIStoreBridge`: compatibility hook exposing legacy `useUIStore` shape over split stores

### useCanvasStore (state essentials)
- `pages: Record<pageId, CanvasItem[]>`
- `pageOrder: string[]`
- `currentPageId: string` (session)
- `currentStep: number` (session)
- `pageColumnCounts: Record<pageId, number>`
- `stepBlocks: StepBlock[]`
- `anchorMap: AnchorMap | null`
- `audioByStep: Record<number, StepAudio>`
- `animationModInput: ModInput | null`
- `insertionIndex: number`
- `currentStroke: StrokeItem | null`
- `selectedItemId: string | null`
- `layoutSnapshot: PersistedCanvasV2 | null`

**Session reset behavior**
- `hydrate(PersistedSlateDoc)` always sets:
  - `currentStep = 0`
  - `currentPageId = first page`

### useUIStoreBridge (compat essentials)
- Tooling/Laser read-write delegates to `useToolStore`.
- Overview/Viewport/View mode/Guides delegates to `useViewportStore`.
- Playback/Sound delegates to `usePlaybackStore`.
- Panels/Fullscreen/Chrome toggles delegates to `useChromeStore`.
- Capability profile/check delegates to `useCapabilityStore`.

---

## Key Flows (Explicit)

### Data Input → Layout
1) Data panel edits `stepBlocks`.
2) `autoLayout` converts blocks into:
   - `pages`
   - `anchorMap`
   - `pageColumnCounts`
3) Result applied via `useCanvasStore.applyAutoLayout(...)`.

### Playback (Global Step)
1) `useSequence` uses `currentStep` + `currentPageId`.
2) Filters items by `stepIndex === currentStep`.
3) If `audioByStep[currentStep]` exists:
   - start audio via `useAudioPlayer`
   - start animation
   - wait for **both** to complete
4) If no audio:
   - wait for animation
5) Delay `autoPlayDelayMs`, then `nextStep()`.

### Rich Text Animation Pipeline
1) `ContentLayer` routes active text items through `RichTextAnimator` (single entrypoint).
2) `compileAnimationPlan` classifies content as `text` / `math` / `mixed`.
3) `measureAnimationPlan` collects run metrics.
4) `playAnimationPlan` executes timeline phases (text reveal, highlight, math reveal).
5) Profile resolution is format-agnostic:
   - external mod payload -> `normalizeModProfile` -> internal `AnimationProfile`.
6) text-only / math-only / mixed all use the same plan/measure/runtime path.
7) Animation runtime must remain font-agnostic:
   - no font-name hardcoding in runtime/model modules.

### Persistence (Doc-only)
- Local autosave and `.slate` export **store doc only**.
- Session fields are never saved.
- `animationModInput` and text segment style payload are persisted with doc data.

### Contract Normalization (Provisional)
1) Tool adapters return `ToolResult` envelope.
2) Tool execution candidates are checked against `ToolRegistry` contract.
3) Core contract guards validate `ToolResult`.
4) `normalized` payload is validated as one of:
   - `NormalizedContent`
   - `RenderPlan`
   - `TTSScript`
5) Export/interchange 경로는 `NormalizedContent`만 수용하며, 나머지 타입은 deterministic error로 반환한다.
6) Connector path(`core/extensions/connectors.ts`)는 registered-tool adapter lookup -> invoke -> ToolResult validate 경로를 담당한다.
7) MCP `call_tool` command route는 command bus 경로를 사용하며, connector path와 별도로 정책/검증을 적용한다.
8) Provider/MCP specific transport adapters stay in `features/extensions/adapters/**`.

### Command Bus / Plugin / MCP (Current Runtime)
1) Declarative plugin clicks and MCP `call_tool` command route 모두 `core/engine/commandBus.ts`로 진입한다.
2) Command bus preflight:
   - payload validator 실행
   - role 판정 (`host | student`)
   - `student + requiresApproval`이면 실행 차단 후 `useSyncStore.pendingAIQueue`로 enqueue
3) Role policy는 `core/config/rolePolicy.ts`에서 중앙화되며, unknown role/surface/action은 deny-by-default로 평가된다.
4) Command/tool approval queue routing hooks는 `features/extensions/commandExecutionPolicy.ts` / `features/extensions/toolExecutionPolicy.ts`에서 role policy를 사용한다.
5) Policy shadow mode(`NEXT_PUBLIC_POLICY_SHADOW=1`)가 켜지면 legacy vs policy 결정 차이를 `features/policy/policyShadow.ts`에서 diff 로깅한다.
6) Core command set(`insertBlock`, `updateBlock`, `deleteBlock`, `setViewMode`, `setAnimating`, `addPage`, `deletePage`, `setColumnCount`, ...)은 `features/extensions/commands/registerCoreCommands.ts`에서 등록된다.
4) Declarative plugin manifest는 `core/extensions/pluginLoader.ts`에서 strict guard로 검증된다.
   - `ui.type`: `button | panel`
   - known slot names only
   - JSON-safe payload/context only
   - no arbitrary function/component injection
5) MCP gateway는 `core/extensions/mcpGateway.ts`에서 postMessage로 동작한다.
   - origin allowlist: `NEXT_PUBLIC_ALLOWED_ORIGIN`
   - handshake token: `NEXT_PUBLIC_MCP_CAPABILITY_TOKEN`
   - session token 발급 후에만 `list_tools` / `call_tool` 허용

---

## Dependency Map (Practical)
**High-level dependency direction**
```
core  -> (no deps outside core)
ui    -> core
features -> core + ui
app   -> features + ui
```

**Concrete dependency hotspots**
- `features/layout/autoLayout.ts`
  - `@core/config/boardSpec`
  - `@core/config/typography`
  - `@core/math/loader`
  - `@core/math/render`
  - `@core/types/canvas`
- `features/hooks/usePersistence.ts`
  - `@core/migrations/migrateToV2`
  - `@core/persistence/buildPersistedDoc`
  - `@core/config/boardSpec`
  - `@core/config/typography`
  - `@features/store/useCanvasStore`
  - `@features/store/useUIStoreBridge`
- `features/hooks/useFileIO.ts`
  - `@core/migrations/migrateToV2`
  - `@core/persistence/buildPersistedDoc`
  - `@features/store/useCanvasStore`
- `features/hooks/useSequence.ts`
  - `@features/store/useCanvasStore`
  - `@features/hooks/useAudioPlayer`
  - `@features/hooks/useSFX`
- `features/canvas/animation/RichTextAnimator.tsx`
  - `@features/animation/model/*`
  - `@features/animation/modding/*`
  - `@features/animation/plan/*`
  - `@features/animation/runtime/*`
  - `@core/math/loader`
  - `@core/math/render`
  - `@features/hooks/useBoardTransform`
- `features/store/useCanvasStore.ts`
  - `@core/config/typography`
  - `@core/types/canvas`
- `core/export/exportPipeline.ts`
  - `@core/contracts/index`

---

## Algorithm Notes (Implementation-Level)

### autoLayout (features/layout/autoLayout.ts)
1) Create **hidden container** with column CSS.
2) For each `StepBlock`:
   - `page-break`: reset container, new page, create anchor at padding origin (48,48).
   - `line-break` / `column-break`: append spacer (`line-break-spacer` / `force-break`), measure anchor.
   - `content`: build DOM nodes, typeset MathJax, check overflow.
3) If overflow: new page, re-append current content.
4) `measureStep` → produce **absolute CanvasItems** + **AnchorPositions**.
5) Output `{ pages, pageOrder, pageColumnCounts, anchorMap }`.

### Playback (features/hooks/useSequence.ts)
1) Collect items where `item.stepIndex === currentStep`.
2) If `audioByStep[currentStep]` exists:
   - play audio (useAudioPlayer)
   - run animation loop (useSequence + animator on active item)
   - await **both** to finish
3) If no audio:
   - run animation only
4) Delay `autoPlayDelayMs`, then `nextStep()`.

### Animation Runtime (features/animation/*)
1) Build plan from typeset DOM:
   - `compileAnimationPlan` creates ordered runs.
2) Measure:
   - `measureAnimationPlan` computes run metrics.
3) Play:
   - `playAnimationPlan` drives rAF timeline with pause/skip/stop/speed.
4) Profile:
   - `normalizeModProfile` converts external mod input (format-agnostic) into `AnimationProfile`.

### Migration (core/migrations/migrateToV2.ts)
1) Normalize pages (`pages`, `pageOrder`).
2) Normalize items (stroke/text/image/math/unknown).
3) Normalize `stepBlocks` (segment order/style) and sanitize rich text HTML/class allowlist.
4) Normalize `animationModInput` if present.
5) Ensure at least 1 page exists.
6) Normalize version (2 or 2.1), return **doc-only** payload (no session fields).

### Persistence (features/hooks/usePersistence.ts)
1) `saveSnapshot` filters **image items** for local storage.
2) Saves **PersistedSlateDoc** only.
3) `hydrate` always resets `currentStep=0` + first page.
4) Autosave is debounce-based on store changes.

### File I/O (.slate) (features/hooks/useFileIO.ts)
**Export**
1) Collect image assets → map to `assets/images/*`
2) Rewrite `image.src` to asset path
3) Write `manifest.json` + `board.json` (doc-only)
**Import**
1) Load `board.json` → `migrateToV2`
2) Map `assets/*` to Blob URLs
3) Hydrate store with doc-only data

---

## Store Mutators (Summary)

### useCanvasStore (selected actions)
- `addStroke`, `addItem`, `updateItem`, `deleteItem`: mutate `pages` items.
- `importStepBlocks`: rebuilds `pages`, clears `anchorMap`, resets `currentStep=0`.
- `insertBreak`: inserts break block at target index, rebuilds layout.
- `applyAutoLayout`: apply `{ pages, pageOrder, anchorMap }`, reset step.
- `setColumnCount / increaseColumns / decreaseColumns`: adjust per-page column counts.
- `addPage / deletePage / goToPage / isPageEmpty`: page management helpers.
- `setStepAudio / clearStepAudio`: mutate `audioByStep`.
- `setAnimationModInput`: updates persisted modding payload for animation profile input.
- `nextStep / prevStep / goToStep / resetStep`: session-only step navigation.
- `nextPage / prevPage`: session-only page navigation.
- `captureLayoutSnapshot / restoreLayoutSnapshot`: doc snapshot + restore.

### useUIStoreBridge (selected actions)
- `triggerPlay / triggerStop / triggerSkip`: increments signal counters.
- `toggleBreakGuides / toggleCanvasBorder`: layout guide visibility toggles.
- `setAutoPlay / setPaused`: playback controls.
- `setPlaybackSpeed / setAutoPlayDelay`: timing controls.
- `openDataInput / closeDataInput`: data panel visibility.

---

## Persistence: Doc vs Session

**PersistedSlateDoc (saved/exported)**
```json
{
  "version": 2,
  "pages": { "page-1": [] },
  "pageOrder": ["page-1"],
  "pageColumnCounts": { "page-1": 2 },
  "stepBlocks": [],
  "anchorMap": {},
  "audioByStep": {},
  "animationModInput": null
}
```

**Session state (runtime only)**
```json
{
  "currentPageId": "page-1",
  "currentStep": 0
}
```

---

## Extension Scaffolding (Contract-first Boundary)
Located in `core/extensions/`:
- `manifest.ts`: permissions, triggers, UI placement
- `registry.ts`: extension registry + tool registry entry store
- `connectors.ts`: registered-tool gate + adapter lookup/invoke contract + ToolResult validation
- `pluginLoader.ts`: strict declarative plugin manifest v1 validator/registry
- `mcpGateway.ts`: postMessage-based MCP-compatible secure gateway runtime
- `runtime.ts`: script manifest + trigger registry (no direct network execution)

Located in `features/extensions/adapters/`:
- `types.ts`: adapter interface (`adapterId`, `supports`, `invoke`, `health`)
- `registry.ts`: feature-layer adapter registry (`register/get/list/clear`)
- `mockAdapter.ts`: deterministic local adapter for boundary validation
- `index.ts`: adapter exports + default registration helper

Located in `features/extensions/`:
- `commandExecutionPolicy.ts`: command bus role/approval queue policy hooks
- `toolExecutionPolicy.ts`: connector tool execution role/approval queue policy hooks
- `commands/registerCoreCommands.ts`: core command registrations for doc mutation facade
- `ui/ExtensionRuntimeBootstrap.tsx`: slot/adapters/policy/command/mcp runtime bootstrap
- `ui/registerCoreDeclarativeManifest.ts`: declarative core toolbar shadow/cutover manifest registration
- `ui/registerCoreSlots.ts`: core slot registrations (pending approvals + layout cutover slot components)
- `ui/CoreSlotComponents.tsx`: slot-wrapped core UI components for phased layout cutover

**Permission scope examples**
- `canvas:read`, `canvas:write`, `net:http`, `llm:invoke`

---

## Invariants (Do Not Break)
- **Global Step**: never reset per-page.
- **Doc-only persistence**: never store session fields.
- **Sanitize HTML**: any `innerHTML` must be sanitized upstream (DOMPurify or allowlist sanitizer).
- **Layer boundaries**: `core` must not import `features` or `ui`.
- **JSON-safe persistence**: no DOM/Function in persisted payloads.

---

## Common Entry Points
- Next app shell: `app/layout.tsx`
- Layout root: `features/layout/AppLayout.tsx`
- Playback engine: `features/hooks/useSequence.ts`
- Persistence: `features/hooks/usePersistence.ts`
- File I/O: `features/hooks/useFileIO.ts`
- Data input panel: `features/layout/DataInputPanel.tsx`
- Auto layout: `features/layout/autoLayout.ts`

---

## Migration Baseline (Task 119~138)
- Baseline info check:
  - `scripts/check_v10_migration_baseline.sh`
- Legacy freeze guard:
  - `scripts/check_v10_legacy_freeze.sh`
- Layer boundary check:
  - `scripts/check_layer_rules.sh`
- Repository shell verification bundle:
  - `bash scripts/run_repo_verifications.sh`
- Build gates:
  - `cd v10 && npm run lint`
  - `cd v10 && npm run build`

Current migration command domains (source of truth):
- `features/extensions/commands/registerCoreCommands.ts` -> `COMMAND_MIGRATION_MAP`
- Optional policy/shadow/cutover flags:
  - `NEXT_PUBLIC_POLICY_SHADOW=1`: enable policy shadow diff telemetry (legacy vs policy decisions).
  - `NEXT_PUBLIC_CORE_MANIFEST_SHADOW=1`: enable declarative core toolbar shadow manifest injection.
  - `NEXT_PUBLIC_CORE_TOOLBAR_CUTOVER=1`: enable declarative toolbar cutover path for playback/page/break controls.
  - `NEXT_PUBLIC_LAYOUT_SLOT_CUTOVER=1`: enable phased layout slot cutover path (left panel + bottom region slot composition).
